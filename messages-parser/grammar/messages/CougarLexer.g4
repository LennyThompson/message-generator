lexer grammar CougarLexer;

@lexer::header {
}

ENDL: (EOF | '\r'? '\n') -> skip;
COMMENT: '//' ~[\r\n]* ENDL -> skip;
C_COMMENT: '/*' .*? '*/' -> skip;


WHITE_SPACE: (' ' | '\t' )+ -> skip;

HASH_MACRO : HASH -> pushMode(MACRO);

STRUCT: 'struct' -> pushMode(STRUCT_MODE);

ENUM: 'enum' -> pushMode(ENUM_MODE);

END_OF_LINE: SEMI_COLON;

fragment DIGIT : [0-9];

fragment A : [aA];
fragment B : [bB];
fragment C : [cC];
fragment D : [dD];
fragment E : [eE];
fragment F : [fF];
fragment G : [gG];
fragment H : [hH];
fragment I : [iI];
fragment J : [jJ];
fragment K : [kK];
fragment L : [lL];
fragment M : [mM];
fragment N : [nN];
fragment O : [oO];
fragment P : [pP];
fragment Q : [qQ];
fragment R : [rR];
fragment S : [sS];
fragment T : [tT];
fragment U : [uU];
fragment V : [vV];
fragment W : [wW];
fragment X : [xX];
fragment Y : [yY];
fragment Z : [zZ];

fragment LOWER: [a-z];
fragment UPPER: [A-Z];

fragment FULL_STOP: '.';
fragment APOSTROPHE: '\'';
fragment COLON: ':';
fragment SEMI_COLON: ';';
fragment COMMA: ',';
fragment PLUS: '+';
fragment MINUS: '-';
fragment DIVIDE: '/';
fragment TIMES: '*';
fragment ASSIGN: '=';
fragment AT: '@';
fragment HASH: '#';
fragment QUESTION: '?';
fragment DOLLAR: '$';
fragment OPEN: '(';
fragment CLOSE: ')';
fragment OPEN_BRACE: '{';
fragment CLOSE_BRACE: '}';
fragment OPEN_ANGLE_BRACE: '<';
fragment CLOSE_ANGLE_BRACE: '>';
fragment BACKSLASH: '\\';
fragment EXCLAIM: '!';
fragment SLASH: '/';

fragment SINGLE_QUOTE: '\'';
fragment DOUBLE_QUOTE: '"';
fragment OPEN_SQ_BRACKET: '[';
fragment CLOSE_SQ_BRACKET: ']';
fragment LESS_THAN: '<';
fragment GREATER_THAN: '>';

fragment
    HEXDIGIT    :   [a-fA-F0-9] ;
fragment
    NUMERIC: DIGIT+ (PERIOD DIGIT+)?;
fragment
    HEXNUMERIC : '0' X HEXDIGIT+;
fragment
    START_CHAR : (LOWER | UPPER | '_' | PLUS | MINUS | DIVIDE | TIMES | SINGLE_QUOTE);
fragment
    SIMPLE_WORD_CHAR :
    (
        START_CHAR
        | DIGIT
    );
fragment
    WORD_CHAR :
    (
        START_CHAR
        | APOSTROPHE
        | DIGIT
        | COLON
        | COMMA
        | PERIOD
        | SEMI_COLON
        | SINGLE_QUOTE
        | OPEN_SQ_BRACKET
        | CLOSE_SQ_BRACKET
        | HASH
        | QUESTION
        | EXCLAIM
        | GREATER_THAN
    );
fragment
   FILTER_VALUE_CHAR :
        ( LOWER | UPPER | '_' )
        ;
fragment SIMPLE_WORD : (LOWER | UPPER) SIMPLE_WORD_CHAR* ;
fragment SIMPLE_NAME : (LOWER | UPPER) ( SIMPLE_WORD_CHAR '_')+ ;

fragment
    MEMBER_NAME_START: 'm_';
fragment
    QUOTED_STRING: (SINGLE_QUOTE | DOUBLE_QUOTE) ~['"]* (SINGLE_QUOTE | DOUBLE_QUOTE);
fragment NEW_LINE : '\r'? '\n' | '\r';

fragment WABFILTER : W A B F I L T E R;
fragment FIELDDESC : F I E L D D E S C;
fragment FIELD : F I E L D;
fragment CATEGORY : C A T E G O R Y;
fragment DESCRIPTION : D E S C R I P T I O N;
fragment GENERATOR : G E N E R A T O R;
fragment CONSUMER : C O N S U M E R;
fragment ALERTLEVEL : A L E R T L E V E L;
fragment REASON : R E A S O N;

fragment ATTRIBUTE_MARKER : SLASH SLASH (SPACE | SLASH)? AT ;

fragment ARITMETIC_EXPR : (PLUS | MINUS | DIVIDE | TIMES | OPEN_ANGLE_BRACE | CLOSE_ANGLE_BRACE | ASSIGN)+;

mode STRUCT_MODE;

CATEGORY_ATTRIBUTE : ATTRIBUTE_MARKER CATEGORY -> pushMode(CATEGORY_MODE);
WABFILTER_ATTRIBUTE : ATTRIBUTE_MARKER WABFILTER -> pushMode(WABFILTER_MODE);
FIELDDESC_ATTRIBUTE : ATTRIBUTE_MARKER (FIELDDESC | FIELD) -> pushMode(FIELDDESC_MODE);
DESCRIPTION_ATTRIBUTE : ATTRIBUTE_MARKER DESCRIPTION -> pushMode(DESCRIPTION_MODE);
GENERATOR_ATTRIBUTE : ATTRIBUTE_MARKER GENERATOR -> pushMode(GENERATOR_MODE);
CONSUMER_ATTRIBUTE : ATTRIBUTE_MARKER CONSUMER -> pushMode(CONSUMER_MODE);
ALERTLEVEL_ATTRIBUTE : ATTRIBUTE_MARKER ALERTLEVEL -> pushMode(ALERTLEVEL_MODE);
REASON_ATTRIBUTE : ATTRIBUTE_MARKER REASON -> pushMode(REASON_MODE);

OPEN_ANG_BRACE : OPEN_ANGLE_BRACE;
CLOSE_ANG_BRACE : CLOSE_ANGLE_BRACE;
TYPE_DELIM : COMMA;

ATTRIBUTE:  ATTRIBUTE_MARKER -> pushMode(ATTRIBUTE_MODE);

NAME_CHAR : (UPPER | LOWER | '_' | DIGIT);
NAME_START_CHAR : [A-Z_];

OPEN_SQUARE_BRACKET : OPEN_SQ_BRACKET -> pushMode(ARRAY_SIZE);

SHORT: S H O R T;
INT: I N T;
USHORT: U S H O R T;
ULONG: U L O N G;
CHAR: C H A R;
BOOL: B O O L;
DWORD: D W O R D;
FILETIME: F I L E T I M E;
BYTE: B Y T E;
FLOAT: F L O A T;
DOUBLE: D O U B L E;
LONGLONG: L O N G L O N G;
LONG: L O N G;
STD: S T D COLON COLON;
VECTOR: V E C T O R;
STRING: S T R I N G;
MAP: M A P;

NAME: NAME_START_CHAR NAME_CHAR*;
MEMBER_NAME: MEMBER_NAME_START? NAME_CHAR+;

OPEN_BRACKET : OPEN_BRACE;
CLOSE_BRACKET : CLOSE_BRACE -> popMode;
MEMBER_END : ';';

SPACE           :   [ \t\r\n]  -> skip;

MSG_COMMENT: '//' -> pushMode(MESSAGE_COMMENT);

mode ENUM_MODE;

ENUM_VALUE: DIGIT+;
ENUM_HEX_VALUE: HEXNUMERIC;

ENUM_NAME_START_CHAR : (LOWER | UPPER | '_');
ENUM_NAME_CHAR : (ENUM_NAME_START_CHAR | DIGIT);

ENUM_NAME : ENUM_NAME_START_CHAR ENUM_NAME_CHAR+;
ENUM_ASSIGN : ASSIGN;
ENUM_COMMA: COMMA;

OPEN_ENUM_BRACKET : OPEN_BRACE;
CLOSE_ENUM_BRACKET : CLOSE_BRACE -> popMode;
ENUM_SPACE           :   [ \t\r\n]  -> skip;
ENUM_COMMENT: '//' -> pushMode(ENUM_COMMENT_MODE);

mode ATTRIBUTE_MODE;

// Use the lexer to identify enum descriptions in the sttribute documentation
// This will see space before it has been skipped.


ATTRIBUTE_ENUM: DIGIT+ ATTR_SPACE? ASSIGN ATTR_SPACE? WORD_CHAR+;

CURRENCY_VALUE: DOLLAR;
NUMERIC_ATTR_VALUE: NUMERIC;
ATTRIBUTE_QUOTED_VALUE: QUOTED_STRING;
HASH_ATTRIBUTE_VALUE: HASH WORD_CHAR*;
QUESTION_ATTRIBUTE_VALUE: QUESTION WORD_CHAR*;
OPERATOR_ATTRIBUTE_VALUE: (ASSIGN+ | LESS_THAN ASSIGN | GREATER_THAN ASSIGN | PLUS ASSIGN | MINUS ASSIGN);
MEMBER_REFERENCE: PERIOD WORD_CHAR+;
ATTRIBUTE_VALUE: START_CHAR WORD_CHAR*;

ENUM_SEPARATOR: COMMA;
ATTRIBUTE_COLON: COLON;
ATTRIBUTE_SEPARATOR: '|';
ATTRIBUTE_OPEN_BRACE: OPEN;
ATTRIBUTE_CLOSE_BRACE: CLOSE FULL_STOP?;
PERIOD: FULL_STOP;

ATTR_EXCLAIM : EXCLAIM -> skip;
ATTR_SPACE : [ \t]  -> skip;
ATTR_END : NEW_LINE -> popMode;

mode WABFILTER_MODE;

GHOSTHOUR : 'G' 'H' 'O' 'S' 'T' 'H' 'O' 'U' 'R';
GHOST : 'G' 'H' 'O' 'S' 'T';
SUBSITE : 'S' 'U' 'B' '_'? 'S' 'I' 'T' 'E';
SITEHOUR : 'S' 'I' 'T' 'E' 'H' 'O' 'U' 'R';
WATSITE : 'W' 'A' 'T' 'S' 'I' 'T' 'E';
SITE : 'S' 'I' 'T' 'E';
WATHOST : 'W' 'A' 'T' 'H' 'O' 'S' 'T';
LHOST : 'L' 'H' 'O' 'S' 'T';
HOST : 'H' 'O' 'S' 'T';
NSAWAB : 'N' 'S' 'A' 'W' 'A' 'B' ;

WABFILTER_COLON : COLON ;
WABFILTER_PERIOD : PERIOD ;
WABFILTER_VALUE : FILTER_VALUE_CHAR (FILTER_VALUE_CHAR | DIGIT)* ;
WABFILTER_SPACE : [ \t]  -> skip;
WABFILTER_END : NEW_LINE -> popMode;

mode FIELDDESC_MODE;

FIELDDESC_SEPARATOR : '|' ;
FIELDDESC_NUMERIC : NUMERIC ;
FIELDDESC_HEX : HEXNUMERIC ;
FIELDDESC_WORD : START_CHAR WORD_CHAR* ;
FIELDDESC_EXPR : ARITMETIC_EXPR;
FIELDDESC_PUNCTUATION : EXCLAIM | PERIOD | COMMA | HASH | QUESTION;
FIELDDESC_DOLLARS : DOLLAR NUMERIC?;
FIELDDESC_QUOTE : DOUBLE_QUOTE ;
FIELDDESC_OPEN : OPEN ;
FIELDDESC_CLOSE : CLOSE ;
FIELDDESC_SPACE : [ \t]  -> skip;
FIELDDESC_END : NEW_LINE -> popMode;

mode CATEGORY_MODE;

CATEGORY_WORD : START_CHAR WORD_CHAR* ;
CATEGORY_SEPARATOR : COMMA ;
CATEGORY_SPACE : [ \t]  -> skip;
CATEGORY_END : NEW_LINE -> popMode;

mode DESCRIPTION_MODE;

DESCRIPTION_SEPARATOR : '|' ;
DESCRIPTION_COLON : COLON ;
DESCRIPTION_DASH : MINUS ;
DESCRIPTION_NUMERIC : NUMERIC ;
DESCRIPTION_HEX : HEXNUMERIC ;
DESCRIPTION_WORD : START_CHAR WORD_CHAR* ;
DECSRIPTION_KEYWORD : (SITE | SUBSITE | HOST | GHOST | SITEHOUR | GHOSTHOUR);
DESCRIPTION_PUNC : (QUESTION | PERIOD |  EXCLAIM ) ;
DESCRIPTION_OPEN : OPEN ;
DESCRIPTION_CLOSE : CLOSE ;
DESCRIPTION_SPACE : [ \t]  -> skip;
DESCRIPTION_END : NEW_LINE -> popMode;

mode GENERATOR_MODE;

GENERATOR_WORD : START_CHAR WORD_CHAR* ;
GENERATOR_SEPARATOR : COMMA ;
GENERATOR_OPEN : OPEN ;
GENERATOR_CLOSE : CLOSE ;
GENERATOR_SPACE : [ \t]  -> skip;
GENERATOR_END : NEW_LINE -> popMode;

mode CONSUMER_MODE;

CONSUMER_WORD : START_CHAR WORD_CHAR* ;
CONSUMER_SEPARATOR : COMMA ;
CONSUMER_SPACE : [ \t]  -> skip;
CONSUMER_END : NEW_LINE -> popMode;

mode ALERTLEVEL_MODE;

ALERTLEVEL_WORD : START_CHAR WORD_CHAR* ;
ALERTLEVEL_SEPARATOR : COMMA ;
ALERTLEVEL_SPACE : [ \t]  -> skip;
ALERTLEVEL_END : NEW_LINE -> popMode;

mode REASON_MODE;

REASON_SEPARATOR : '|' ;
REASON_NUMERIC : NUMERIC ;
REASON_HEX : HEXNUMERIC ;
REASON_WORD : START_CHAR WORD_CHAR* ;
REASON_OPEN : OPEN ;
REASON_CLOSE : CLOSE ;
REASON_SPACE : [ \t]  -> skip;
REASON_END : NEW_LINE -> popMode;


mode ARRAY_SIZE;

ARRAY_SIZE_SPACE: [ \t] -> skip;
CONST_NUMBER: DIGIT+;
OPERATOR: PLUS | MINUS | TIMES | DIVIDE;
SIZE_VALUE: NAME_START_CHAR (NAME_START_CHAR | DIGIT)+;
CLOSE_SQUARE_BRACKET : CLOSE_SQ_BRACKET -> popMode;


mode MESSAGE_COMMENT;

MSG_SPACE: [ \t] -> skip;
MSG_WORD: START_CHAR WORD_CHAR*;
MSG_CURRENCY_VALUE: DOLLAR NUMERIC;
MSG_NUMBER: BACKSLASH? NUMERIC;
MSG_PERIOD: FULL_STOP;
MSG_OPEN_BRACE: OPEN;
MSG_CLOSE_BRACE: CLOSE FULL_STOP?;
MSG_COLON: COLON;
MSG_UNKNOWN: QUESTION QUESTION;
MSG_END: NEW_LINE  -> popMode;

mode ENUM_COMMENT_MODE;

ENUM_COMMENT_CONTENT: ~[\r\n] -> skip;
ENUM_COMMENT_END: NEW_LINE  -> popMode;

mode MULTILINE_COMMENT;

ANY_CONTENT: ~[*/]  -> skip;
END_COMMENT: '*/' -> popMode;

mode MACRO;

MACRO_WS: [ \t] -> skip;
MACRO_COMMENT: '//' ~[\r\n]* -> skip;
MACRO_END: '\r'? '\n'  -> popMode;
MACRO_OPEN: OPEN;
MACRO_CLOSE: CLOSE;
MACRO_OPEN_ANGLE_BRACE: OPEN_ANGLE_BRACE;
MACRO_CLOSE_ANGLE_BRACE: CLOSE_ANGLE_BRACE;
MACRO_QUOTE: '"';
MACRO_COMMA: ',';
MACRO_PLUS: PLUS;
MACRO_NUMBER: DIGIT+;
MACRO_HEX_NUMBER: HEXNUMERIC;
EQUALS: '==';
GREATER_THAN_EQUALS: '>=';
LESS_THAN_EQUALS: '<=';
AND: '&&';
OR: '||';
MACRO_NOT: '!';

INCLUDE: I N C L U D E;
DEFINED: D E F I N E D;
DEFINE: D E F I N E;
IF: I F;
IFNDEF: I F N D E F;
ENDIF: E N D I F;
UNDEF: U N D E F;
PRAGMA: P R A G M A;
ONCE: O N C E;

START_MACRO_NAME_CHAR: [a-z] | [A-Z] | '_';
MACRO_NAME_CHAR : (START_MACRO_NAME_CHAR | DIGIT);
MACRO_NAME: START_MACRO_NAME_CHAR MACRO_NAME_CHAR+;
MACRO_QUOTED_STRING: QUOTED_STRING;

HEADER_EXTENSION: '.h';
